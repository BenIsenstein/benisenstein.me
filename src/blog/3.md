---
title: "Golang Data Types and Heap-Based Priority Queue"
datePublished: 2025-02-11
dateLastUpdated: 2025-02-11
---

Golang offers a variety of built-in data types that facilitate strong and efficient type safety. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec eget diam erat. Vestibulum ut arcu at turpis aliquet tincidunt. Suspendisse et nisl at libero consequat malesuada.

## Common Golang Data Types

Below is a table listing some fundamental data types in Golang:

| Data Type  | Description |
|------------|-------------------------------------------------|
| `int`      | Integer type (platform-dependent size) |
| `int8`     | 8-bit integer (-128 to 127) |
| `int16`    | 16-bit integer (-32,768 to 32,767) |
| `int32`    | 32-bit integer (-2,147,483,648 to 2,147,483,647) |
| `int64`    | 64-bit integer (-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807) |
| `float32`  | 32-bit floating point number |
| `float64`  | 64-bit floating point number |
| `string`   | Sequence of characters |
| `bool`     | Boolean type (true or false) |
| `byte`     | Alias for `uint8` |
| `rune`     | Alias for `int32`, used for Unicode characters |
| `array`    | Fixed-size sequence of elements of the same type |
| `slice`    | Dynamically sized sequence of elements |
| `map`      | Key-value pair collection |
| `struct`   | Composite data type grouping different fields |
| `interface`| Abstract type for method signatures |

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras gravida, tortor sed tincidunt tempus, justo purus aliquet nunc, id convallis purus dui at mauris.

## Implementing a Heap-Based Priority Queue in Golang

Below is a Go implementation of a heap-based priority queue:

```go
package main

import (
	"container/heap"
	"fmt"
)

type Item struct {
	value    string
	priority int
	index    int
}

type PriorityQueue []*Item

func (pq PriorityQueue) Len() int { return len(pq) }

func (pq PriorityQueue) Less(i, j int) bool {
	return pq[i].priority > pq[j].priority
}

func (pq PriorityQueue) Swap(i, j int) {
	pq[i], pq[j] = pq[j], pq[i]
	pq[i].index = i
	pq[j].index = j
}

func (pq *PriorityQueue) Push(x interface{}) {
	item := x.(*Item)
	item.index = len(*pq)
	*pq = append(*pq, item)
}

func (pq *PriorityQueue) Pop() interface{} {
	n := len(*pq)
	item := (*pq)[n-1]
	*pq = (*pq)[:n-1]
	return item
}

func main() {
	pq := make(PriorityQueue, 0)
	heap.Init(&pq)
	heap.Push(&pq, &Item{value: "task1", priority: 3})
	heap.Push(&pq, &Item{value: "task2", priority: 1})
	heap.Push(&pq, &Item{value: "task3", priority: 2})

	for pq.Len() > 0 {
		item := heap.Pop(&pq).(*Item)
		fmt.Printf("%s with priority %d\n", item.value, item.priority)
	}
}
```

### Conclusion

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer nec odio. Praesent libero. Sed cursus ante dapibus diam. Nam nec risus at odio consectetur feugiat. Quisque pharetra, turpis ut rhoncus fringilla, felis est scelerisque quam, sit amet vulputate risus nunc a eros.

